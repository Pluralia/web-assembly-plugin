{
  parserClass="org.jetbrains.webstorm.lang.parser.WebAssemblyParser"

  psiClassPrefix="WebAssembly"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.webstorm.lang.psi"
  psiImplPackage="org.jetbrains.webstorm.lang.psi.impl"

  elementTypeHolderClass="org.jetbrains.webstorm.lang.psi.WebAssemblyTypes"
  elementTypeClass="org.jetbrains.webstorm.lang.psi.WebAssemblyElementType"         // lang.psi.ElementTypes
  tokenTypeClass="org.jetbrains.webstorm.lang.psi.WebAssemblyTokenType"             // lang.psi.ElementTypes

  psiImplUtilClass="org.jetbrains.webstorm.lang.psi.impl.WebAssemblyPsiImplUtil"
}

webAssemblyFile ::= item_*

private item_ ::= comment | module | modulefield+

comment ::= LINE_COMMENT | BLOCK_COMMENT

module ::= LPAR MODULEKEY IDENTIFIER? modulefield* RPAR
modulefield ::= type | import | func | table | mem | global | export | start | elem | data


// types
functype ::= LPAR FUNCKEY param* result* RPAR
param ::= LPAR PARAMKEY (IDENTIFIER VALTYPE | VALTYPE+) RPAR
result ::= LPAR RESULTKEY VALTYPE+ RPAR

memtype ::= UNSIGNED UNSIGNED?      // limits
tabletype ::= memtype FUNCREFKEY

globaltype ::= VALTYPE | LPAR MUTKEY VALTYPE RPAR


// instructions
instr ::= foldeinstr | plaininstr | blockinstr

blocktype ::= result | typeuse
blockinstr ::= (BLOCKKEY | LOOPKEY) IDENTIFIER? blocktype? instr* ENDKEY IDENTIFIER?
             | foldeinstr* IFKEY IDENTIFIER? blocktype? instr* (ELSEKEY IDENTIFIER? instr*)? ENDKEY IDENTIFIER?
plaininstr ::= CONTROLINSTR
             | CONTROLINSTR_IDX idx
             | BRTABLEINSTR idx*
             | CALLINDIRECTINSTR typeuse
             | PARAMETRICINSTR
             | VARIABLEINSTR_IDX idx
             | MEMORYINSTR
             | MEMORYINSTR_MEMARG (OFFSETEQKEY UNSIGNED)? (ALIGNEQKEY UNSIGNED)?
             | ICONST (UNSIGNED | SIGNED)
             | FCONST (FLOAT | UNSIGNED | SIGNED)
             | NUMERICINSTR
foldeinstr ::= LPAR plaininstr foldeinstr* RPAR
             | LPAR (BLOCKKEY | LOOPKEY) IDENTIFIER? blocktype? instr* RPAR IDENTIFIER?
             | LPAR IFKEY IDENTIFIER? blocktype? foldeinstr* LPAR THENKEY instr* RPAR LPAR ELSEKEY instr* RPAR RPAR


// modules
// indices
idx ::= UNSIGNED | IDENTIFIER

// types
type ::= LPAR TYPEKEY IDENTIFIER? functype RPAR

// type uses
typeuse ::= (LPAR TYPEKEY idx RPAR)? param* result*

// imports
import ::= LPAR IMPORTKEY STRING STRING importdesc RPAR
importdesc ::= LPAR FUNCKEY IDENTIFIER? typeuse RPAR
             | LPAR TABLEKEY IDENTIFIER? tabletype RPAR
             | LPAR MEMORYKEY IDENTIFIER? memtype RPAR
             | LPAR GLOBALKEY IDENTIFIER? globaltype RPAR
inline_import ::= LPAR IMPORTKEY STRING STRING RPAR

// functions
func ::= LPAR FUNCKEY IDENTIFIER? (
            inline_import typeuse
          | (inline_export (inline_export | inline_import)?)? typeuse local* instr*
         ) RPAR
local ::= LPAR LOCALKEY (IDENTIFIER VALTYPE | VALTYPE+) RPAR

// tables
table ::= LPAR TABLEKEY IDENTIFIER? (
             inline_elem
           | inline_import? tabletype
           | inline_export (inline_import | inline_export | inline_elem)?
          ) RPAR

// memories
mem ::= LPAR MEMORYKEY IDENTIFIER? (
           inline_data
         | inline_import? memtype
         | inline_export (inline_import | inline_export | inline_data)?
        ) RPAR

// globals
global ::= LPAR GLOBALKEY IDENTIFIER? (
              inline_import globaltype
            | (inline_export (inline_import | inline_export)?)? globaltype instr*
           ) RPAR

// exports
export ::= LPAR EXPORTKEY STRING exportdesc RPAR
exportdesc ::= LPAR (FUNCKEY | TABLEKEY | MEMORYKEY | GLOBALKEY) idx RPAR
inline_export ::= LPAR EXPORTKEY STRING RPAR

// start function
start ::= LPAR STARTKEY idx RPAR

// element segments
elem ::= LPAR ELEMKEY idx? (instr | LPAR OFFSETKEY instr* RPAR) idx* RPAR
inline_elem ::= FUNCREFKEY LPAR ELEMKEY idx* RPAR

// data segments
data ::= LPAR DATAKEY idx? (instr | LPAR OFFSETKEY instr* RPAR) STRING* RPAR
inline_data ::= LPAR DATAKEY STRING* RPAR

// only lexer tokens
lexer_tokens ::= BAD_KEYWORD