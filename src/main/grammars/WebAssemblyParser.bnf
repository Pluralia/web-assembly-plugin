{
  parserClass="org.jetbrains.webstorm.lang.parser.WebAssemblyParser"

  psiClassPrefix="WebAssembly"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.webstorm.lang.psi"
  psiImplPackage="org.jetbrains.webstorm.lang.psi.impl"

  elementTypeHolderClass="org.jetbrains.webstorm.lang.psi.WebAssemblyTypes"
  elementTypeClass="org.jetbrains.webstorm.lang.psi.WebAssemblyElementType"         // lang.psi.ElementTypes
  tokenTypeClass="org.jetbrains.webstorm.lang.psi.WebAssemblyTokenType"             // lang.psi.ElementTypes

  psiImplUtilClass="org.jetbrains.webstorm.lang.psi.impl.WebAssemblyPsiImplUtil"
}

webAssemblyFile ::= item_*

private item_ ::= comment | module | modulefield+

comment ::= LINE_COMMENT | BLOCK_COMMENT

module ::= LPAR MODULEKEY IDENTIFIER? modulefield* RPAR
modulefield ::= type | import | func | table | mem | global | export | start | elem | data


// types
valtype ::= NUMTYPE | REFTYPE

functype ::= LPAR FUNCKEY param* result* RPAR
param ::= LPAR PARAMKEY (IDENTIFIER valtype | valtype*) RPAR
result ::= LPAR RESULTKEY valtype* RPAR

memtype ::= UNSIGNED UNSIGNED?      // limits
tabletype ::= memtype REFTYPE

globaltype ::= valtype | LPAR MUTKEY valtype RPAR


// instructions
instr ::= foldeinstr | plaininstr | blockinstr

blocktype ::= result | typeuse
blockinstr ::= (BLOCKKEY | LOOPKEY) IDENTIFIER? blocktype? instr* ENDKEY IDENTIFIER?
             | foldeinstr* IFKEY IDENTIFIER? blocktype? instr* (ELSEKEY IDENTIFIER? instr*)? ENDKEY IDENTIFIER?
plaininstr ::=
             // control
               CONTROLINSTR
             | CONTROLINSTR_IDX idx
             | BRTABLEINSTR idx+
             | CALLINDIRECTINSTR idx? typeuse
             // reference
             | REFDOTISNULLINST
             | REFDOTNULLINSTR (FUNCKEY | EXTERNKEY)
             | REFDOTFUNCINSTR idx
             // parametric
             | PARAMETRICINSTR
             // variable
             | VARIABLEINSTR_IDX idx
             // table
             | TABLEINSTR_IDX idx?
             | TABLEINSTR_IDX_IDX idx? idx?
             | TABLEINSTR_IDX_ELIDX idx idx?
             | TABLEINSTR_ELIDX idx
             // memory
             | MEMORYINSTR
             | MEMORYINSTR_IDX idx
             | MEMORYINSTR_MEMARG (OFFSETEQKEY UNSIGNED)? (ALIGNEQKEY UNSIGNED)?
             // numeric
             | ICONST (UNSIGNED | SIGNED)
             | FCONST (FLOAT | UNSIGNED | SIGNED)
             | NUMERICINSTR
foldeinstr ::= LPAR plaininstr foldeinstr* RPAR
             | LPAR (BLOCKKEY | LOOPKEY) IDENTIFIER? blocktype? instr* RPAR IDENTIFIER?
             | LPAR IFKEY IDENTIFIER? blocktype? foldeinstr* LPAR THENKEY instr* RPAR LPAR ELSEKEY instr* RPAR RPAR


// modules
// indices
idx ::= UNSIGNED | IDENTIFIER

// types
type ::= LPAR TYPEKEY IDENTIFIER? functype RPAR

// type uses
typeuse ::= (LPAR TYPEKEY idx RPAR)? param* result*

// imports
import ::= LPAR IMPORTKEY STRING STRING importdesc RPAR
importdesc ::= LPAR FUNCKEY IDENTIFIER? typeuse RPAR
             | LPAR TABLEKEY IDENTIFIER? tabletype RPAR
             | LPAR MEMORYKEY IDENTIFIER? memtype RPAR
             | LPAR GLOBALKEY IDENTIFIER? globaltype RPAR
inline_import ::= LPAR IMPORTKEY STRING STRING RPAR

// functions
func ::= LPAR FUNCKEY IDENTIFIER? (
            inline_import typeuse
          | (inline_export (inline_export | inline_import)?)? typeuse local* instr*
         ) RPAR
local ::= LPAR LOCALKEY (IDENTIFIER valtype | valtype*) RPAR

// tables
table ::= LPAR TABLEKEY IDENTIFIER? (
             inline_elem
           | inline_import? tabletype
           | inline_export (inline_import | inline_export | inline_elem)?
          ) RPAR

// memories
mem ::= LPAR MEMORYKEY IDENTIFIER? (
           inline_data
         | inline_import? memtype
         | inline_export (inline_import | inline_export | inline_data)?
        ) RPAR

// globals
global ::= LPAR GLOBALKEY IDENTIFIER? (
              inline_import globaltype
            | (inline_export (inline_import | inline_export)?)? globaltype instr*
           ) RPAR

// exports
export ::= LPAR EXPORTKEY STRING exportdesc RPAR
exportdesc ::= LPAR (FUNCKEY | TABLEKEY | MEMORYKEY | GLOBALKEY) idx RPAR
inline_export ::= LPAR EXPORTKEY STRING RPAR

// start function
start ::= LPAR STARTKEY idx RPAR

// element segments
elem ::= LPAR ELEMKEY IDENTIFIER? (
           (LPAR TABLEKEY idx RPAR)? (instr | LPAR OFFSETKEY instr* RPAR)
         | DECLAREKEY
         )? elemlist RPAR
elemlist ::= REFTYPE (instr | LPAR ITEMKEY instr* RPAR)* | FUNCKEY? idx*
inline_elem ::= REFTYPE LPAR ELEMKEY (instr+ | elemlist)? RPAR

// data segments
data ::= LPAR DATAKEY idx? ((LPAR MEMORYKEY idx RPAR)? (instr | LPAR OFFSETKEY instr* RPAR))? STRING* RPAR
inline_data ::= LPAR DATAKEY STRING* RPAR


// only lexer tokens
lexer_tokens ::= BAD_KEYWORD